<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Competition Display</title>

    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        background-color: #f8fafc;
        color: #1f2937;
        font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        overflow: hidden;
        height: 100vh;
      }

      .container-fluid {
        padding: 1rem 2rem;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        max-width: 1400px;
        margin: 0 auto;
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        margin: 0 -0.5rem;
      }

      .col-12,
      .col-lg-7,
      .col-lg-5,
      .col-md-3 {
        padding: 0 0.5rem;
        width: 100%;
      }

      @media (min-width: 992px) {
        .col-lg-7 {
          width: 58.333333%;
        }
        .col-lg-5 {
          width: 41.666667%;
        }
      }

      .competition-header {
        text-align: center;
        margin-bottom: 1.5rem;
        flex-shrink: 0;
      }

      .main-content-row {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: calc(100vh - 200px);
      }

      .status-row {
        flex-shrink: 0;
        margin-top: 1rem;
      }

      .competition-title {
        font-size: 2.5rem;
        margin-bottom: 0.3rem;
        color: #1f2937;
      }

      .event-name {
        font-size: 1.8rem;
        color: #6b7280;
        margin-bottom: 0.8rem;
      }

      .current-lifter {
        text-align: center;
        margin: 2rem 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: auto;
      }

      .athlete-name {
        font-size: 3rem;
        font-weight: bold;
        text-shadow: none;
        margin-bottom: 0.5rem;
        color: #1f2937;
      }

      .team-name {
        font-size: 1.5rem;
        color: #6b7280;
        margin-bottom: 1rem;
      }

      .current-weight {
        font-size: 6rem;
        font-weight: bold;
        color: #3b82f6;
        text-shadow: none;
        margin: 1rem 0;
      }

      .attempt-info {
        font-size: 2rem;
        margin: 0.5rem 0;
        color: #4b5563;
      }

      .lift-name {
        color: #166534;
        font-weight: bold;
      }

      .timer-large {
        font-size: 4rem;
        font-weight: bold;
        text-align: center;
        color: #166534;
        text-shadow: none;
        margin: 1rem 0;
      }

      .timer-large.running {
        animation: pulse 1s infinite;
      }

      .timer-large.warning {
        color: #d97706;
      }

      .timer-large.expired {
        color: #dc2626;
        animation: blink 0.5s infinite;
      }

      .side-panel {
        display: flex;
        flex-direction: column;
        height: 100%;
      }

      .side-panel > div {
        background-color: #ffffff;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        padding: 1rem;
        margin-bottom: 1rem;
        flex: 1;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      }

      .side-panel h4 {
        margin-bottom: 0.5rem;
        font-size: 1.1rem;
        color: #1f2937;
      }

      .next-lifter-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 0.5rem;
        padding: 0.5rem;
        background-color: #f3f4f6;
        border-radius: 0.5rem;
      }

      .next-lifter-item .weight {
        color: #3b82f6;
        font-weight: bold;
      }

      .rankings-table {
        width: 100%;
        border-collapse: collapse;
      }

      .rankings-table th,
      .rankings-table td {
        padding: 0.5rem;
        text-align: left;
      }

      .rankings-table thead {
        border-bottom: 2px solid #e5e7eb;
      }

      .rankings-table .total-score {
        color: #d97706;
        font-weight: bold;
      }

      .loading-cell {
        text-align: center;
        color: #6b7280;
        font-style: italic;
        padding: 1rem;
      }





      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
      }

      @media (min-width: 992px) {
        .col-lg-7 {
          width: 58.333333%;
        }
        .col-lg-5 {
          width: 41.666667%;
        }
      }





      @media (min-width: 768px) {
        .col-md-3 {
          width: 25%;
        }
      }

      @media (max-width: 1200px) {
        .athlete-name {
          font-size: 2.5rem;
        }
        .current-weight {
          font-size: 5rem;
        }
        .timer-large {
          font-size: 3rem;
        }
        .competition-title {
          font-size: 2rem;
        }
      }

      @media (max-width: 768px) {
        .container-fluid {
          padding: 0.5rem;
        }
        .athlete-name {
          font-size: 2rem;
        }
        .current-weight {
          font-size: 4rem;
        }
        .timer-large {
          font-size: 2.5rem;
        }
        .attempt-info {
          font-size: 1.5rem;
        }
        .competition-title {
          font-size: 1.5rem;
        }
        .main-content-row {
          flex-direction: column;
        }
        .side-panel {
          flex-direction: row;
          height: auto;
        }
        .side-panel > div {
          margin-right: 0.5rem;
          margin-bottom: 0.5rem;
        }
        .error-box {
          padding: 30px;
          width: 95%;
        }
        .error-title {
          font-size: 24px;
        }
        .error-message {
          font-size: 16px;
        }
      }
    </style>
  </head>
  <body>




    <main class="container-fluid">


      <div class="row">
        <div class="col-12 competition-header">
          <h1 class="competition-title"> {% if competition %}{{ competition.name }}{% else %}Select Competition{% endif %}</h1>
          <h2 class="event-name" id="event-name">{% if events %}{{ events[0].name if events else 'No Events' }}{% else %}No Events{% endif %}</h2>
        </div>
      </div>

      <div class="row main-content-row">
        <div class="col-lg-7">
          <div class="current-lifter">
            <div class="athlete-name" id="current-athlete">Loading...</div>
            <div class="team-name" id="current-team">Loading...</div>
            <div class="current-weight" id="current-weight">--kg</div>
            <div class="attempt-info">
              <span class="lift-name" id="current-lift">Loading...</span> -
              <span id="attempt-number">Loading...</span>
            </div>
            <div class="timer-large" id="competition-timer">--:--</div>
          </div>
        </div>

        <div class="col-lg-5 side-panel">
          <div class="next-lifters">
            <h4>üîÑ Next Up</h4>
            <div id="next-lifters-list">
              <div class="next-lifter-item">
                <span>Loading...</span><span class="weight">--kg</span>
              </div>
            </div>
          </div>

          <div class="rankings-display">
            <h4>üèÜ Current Rankings</h4>
            <table class="rankings-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Athlete</th>
                  <th>Total</th>
                </tr>
              </thead>
              <tbody id="rankings-body">
                <tr>
                                  <td colspan="3" class="loading-cell">Loading rankings...</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>


    </main>

    <script>
      console.log('Script started loading...');



      document.addEventListener("DOMContentLoaded", function () {
        let timerInterval = null;



        const timerElement = document.getElementById("competition-timer");
        let duration = 60; // Default duration

        function formatTime(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = seconds % 60;
          return `${mins}:${secs.toString().padStart(2, "0")}`;
        }




        
        // Real-time competition data functions
        async function fetchCompetitionState() {
          {% if competition %}
          try {
            const response = await fetch('/display/api/competition/{{ competition.id }}/state');
            if (response.ok) {
              const data = await response.json();
              if (data.success) {
                updateCurrentAttemptDisplay(data.current_attempt);
                updateNextQueue(data.next_attempts);
                updateAthleteCount(data);
                return data;
              } else {
                console.warn('Failed to fetch competition state:', data.error);
                return null;
              }
            }
            return null;
          } catch (error) {
            console.error('Error fetching competition state:', error);
            return null;
          }
          {% else %}
          return null;
          {% endif %}
        }
        
        async function fetchRankings() {
          {% if competition %}
          try {
            const response = await fetch('/display/api/competition/{{ competition.id }}/rankings');
            if (response.ok) {
              const data = await response.json();
              if (data.success) {
                updateRankingsDisplay(data.rankings);
                return data.rankings;
              } else {
                console.warn('Failed to fetch rankings:', data.error);
                return null;
              }
            }
            return null;
          } catch (error) {
            console.error('Error fetching rankings:', error);
            return null;
          }
          {% else %}
          return null;
          {% endif %}
        }
        
        async function fetchTimerState() {
          try {
            const response = await fetch('/admin/api/timer-state');
            if (response.ok) {
              const timerData = await response.json();
              updateTimerDisplay(timerData);
            }
          } catch (error) {
            console.error('Error fetching timer state:', error);
          }
        }
        
        function updateCurrentAttemptDisplay(currentAttempt) {
          const athleteEl = document.getElementById('current-athlete');
          const teamEl = document.getElementById('current-team');
          const weightEl = document.getElementById('current-weight');
          const liftEl = document.getElementById('current-lift');
          const attemptEl = document.getElementById('attempt-number');
          
          if (currentAttempt) {
            athleteEl.textContent = currentAttempt.athlete.name;
            teamEl.textContent = currentAttempt.athlete.team || 'No Team';
            weightEl.textContent = `${currentAttempt.weight}kg`;
            liftEl.textContent = currentAttempt.movement || currentAttempt.lift_type || 'Unknown Movement';
            attemptEl.textContent = `Attempt ${currentAttempt.attempt_number}`;
            
            // Store current attempt data for potential use
            window.currentAttemptData = currentAttempt;
          } else {
            athleteEl.textContent = 'No Current Attempt';
            teamEl.textContent = 'Waiting for next athlete';
            weightEl.textContent = '--kg';
            liftEl.textContent = 'No Movement';
            attemptEl.textContent = 'Waiting...';
            
            // Clear stored attempt data
            window.currentAttemptData = null;
          }
        }
        
        function updateNextQueue(nextAttempts) {
          const queueContainer = document.getElementById('next-lifters-list');
          queueContainer.innerHTML = '';
          
          if (nextAttempts && nextAttempts.length > 0) {
            // Group by movement type for display
            const movementGroups = {};
            const currentMovement = window.currentAttemptData ? window.currentAttemptData.movement : null;
            
            nextAttempts.forEach(attempt => {
              const movement = attempt.movement || attempt.lift_type || 'Unknown';
              if (!movementGroups[movement]) {
                movementGroups[movement] = [];
              }
              movementGroups[movement].push(attempt);
            });
            
            // Show current movement group first if exists
            let displayedCount = 0;
            const maxDisplay = 6;
            
            if (currentMovement && movementGroups[currentMovement]) {
              const movementHeader = document.createElement('div');
              movementHeader.className = 'movement-header';
              movementHeader.innerHTML = `<small style="color: #166534; font-weight: bold; margin-bottom: 0.5rem; display: block;">Continuing: ${currentMovement}</small>`;
              queueContainer.appendChild(movementHeader);
              
              movementGroups[currentMovement].slice(0, 4).forEach(attempt => {
                if (displayedCount < maxDisplay) {
                  const item = document.createElement('div');
                  item.className = 'next-lifter-item';
                  item.style.backgroundColor = '#f0f9f0'; // Light green for same movement
                  item.innerHTML = `
                    <span>${attempt.athlete.name} <small>(Att. ${attempt.attempt_number})</small></span>
                    <span class="weight">${attempt.weight}kg</span>
                  `;
                  queueContainer.appendChild(item);
                  displayedCount++;
                }
              });
              
              delete movementGroups[currentMovement]; // Remove to avoid duplication
            }
            
            // Show other movements
            Object.keys(movementGroups).forEach(movement => {
              if (displayedCount < maxDisplay && movementGroups[movement].length > 0) {
                const movementHeader = document.createElement('div');
                movementHeader.className = 'movement-header';
                movementHeader.innerHTML = `<small style="color: #6b7280; font-weight: bold; margin-top: 0.5rem; margin-bottom: 0.3rem; display: block;">Next: ${movement}</small>`;
                queueContainer.appendChild(movementHeader);
                
                movementGroups[movement].slice(0, 2).forEach(attempt => {
                  if (displayedCount < maxDisplay) {
                    const item = document.createElement('div');
                    item.className = 'next-lifter-item';
                    item.innerHTML = `
                      <span>${attempt.athlete.name} <small>(Att. ${attempt.attempt_number})</small></span>
                      <span class="weight">${attempt.weight}kg</span>
                    `;
                    queueContainer.appendChild(item);
                    displayedCount++;
                  }
                });
              }
            });
            
            // If no attempts shown, display simple message
            if (displayedCount === 0) {
              const item = document.createElement('div');
              item.className = 'next-lifter-item';
              item.innerHTML = '<span>No waiting attempts</span><span class="weight">--</span>';
              queueContainer.appendChild(item);
            }
          } else {
            const item = document.createElement('div');
            item.className = 'next-lifter-item';
            item.innerHTML = '<span>No athletes in queue</span><span class="weight">--kg</span>';
            queueContainer.appendChild(item);
          }
        }
        
        let lastTimerState = null;
        let timerPollingInterval = null;
        
        function updateTimerDisplay(timerData) {
          const timerEl = document.getElementById('competition-timer');
          
          if (timerData && timerData.timer_seconds !== undefined) {
            // Detect timer start event
            if (timerData.timer_running && (!lastTimerState || !lastTimerState.timer_running)) {
              console.log('Timer started detected - switching to fast polling');
              startFastTimerPolling();
            }
            // Detect timer stop event
            else if (!timerData.timer_running && lastTimerState && lastTimerState.timer_running) {
              console.log('Timer stopped detected - switching to normal polling');
              stopFastTimerPolling();
            }
            
            const seconds = Math.max(0, Math.round(timerData.timer_seconds));
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;
            
            timerEl.textContent = timeStr;
            
            // Update timer styling based on state
            timerEl.classList.remove('running', 'warning', 'expired');
            
            if (timerData.timer_running) {
              timerEl.classList.add('running');
              if (seconds <= 10 && seconds > 0) {
                timerEl.classList.add('warning');
              } else if (seconds === 0) {
                timerEl.classList.add('expired');
              }
            }
            
            lastTimerState = timerData;
          } else {
            timerEl.textContent = '--:--';
          }
        }
        
        function startFastTimerPolling() {
          // Clear existing timer polling if any
          if (timerPollingInterval) {
            clearInterval(timerPollingInterval);
          }
          
          // Start fast polling every 100ms when timer is running
          timerPollingInterval = setInterval(async () => {
            try {
              const response = await fetch('/admin/api/timer-state');
              if (response.ok) {
                const timerData = await response.json();
                updateTimerDisplay(timerData);
              }
            } catch (error) {
              console.error('Error fetching timer state during fast polling:', error);
            }
          }, 100);
        }
        
        function stopFastTimerPolling() {
          if (timerPollingInterval) {
            clearInterval(timerPollingInterval);
            timerPollingInterval = null;
          }
        }
        
        function updateRankingsDisplay(rankings) {
          const rankingsBody = document.getElementById('rankings-body');
          rankingsBody.innerHTML = '';
          
          if (rankings && rankings.length > 0) {
            rankings.forEach(ranking => {
              const row = document.createElement('tr');
              row.innerHTML = `
                <td>${ranking.rank}</td>
                <td>${ranking.athlete.name}</td>
                <td class="total-score">${ranking.total_score}</td>
              `;
              rankingsBody.appendChild(row);
            });
          } else {
            const row = document.createElement('tr');
            row.innerHTML = '<td colspan="3">No rankings available</td>';
            rankingsBody.appendChild(row);
          }
        }
        
        function updateAthleteCount(competitionData) {
          const athleteCountEl = document.getElementById('status-athletes');
          
          if (competitionData && competitionData.athlete_count !== undefined) {
            athleteCountEl.textContent = competitionData.athlete_count;
          } else {
            // Fallback: count from current and next attempts
            let count = 0;
            if (competitionData.current_attempt) count++;
            if (competitionData.next_attempts) {
              const uniqueAthletes = new Set(competitionData.next_attempts.map(a => a.athlete.id));
              count += uniqueAthletes.size;
            }
            athleteCountEl.textContent = count;
          }
        }
        
        // Start real-time polling
        function startRealTimeUpdates() {
          // Fetch initial data
          fetchCompetitionState();
          fetchTimerState();
          fetchRankings();
          
          // Poll every 1 second for competition state (more frequent for better UX)
          setInterval(fetchCompetitionState, 1000);
          
          // Initial timer state fetch and setup smart polling
          fetchTimerState().then(timerData => {
            updateTimerDisplay(timerData);
            // Start with normal 500ms polling - will switch to fast mode when timer starts
            setInterval(async () => {
              if (!timerPollingInterval) { // Only poll if not in fast mode
                const timerData = await fetchTimerState();
                updateTimerDisplay(timerData);
              }
            }, 500);
          });
          
          // Poll every 3 seconds for rankings
          setInterval(fetchRankings, 3000);
        }







        // Start the real-time updates
        {% if competition %}
        startRealTimeUpdates();
        {% endif %}

        console.log("Display interface initialized with real-time data updates.");
      });
    </script>


  </body>
</html>
